# 技术方案文档

## 1. 技术栈选型

### 1.1 前端技术栈
- **框架：** React 18+
- **构建工具：** Vite 5+
- **语言：** TypeScript
- **状态管理：** Zustand 或 Redux Toolkit
- **路由：** React Router v6
- **UI组件库：** 
  - PC端：Ant Design 或 Material-UI
  - 移动端：Ant Design Mobile 或 Vant
- **样式方案：** 
  - CSS-in-JS：styled-components 或 Emotion
  - 或 Tailwind CSS
- **日期处理：** date-fns 或 dayjs
- **日历组件：** 自研或使用 react-big-calendar（需适配）
- **拖拽功能：** react-beautiful-dnd 或 @dnd-kit/core
- **富文本编辑器：** Quill 或 Slate（用于日记功能）
- **Markdown渲染：** react-markdown
- **图表可视化：** Recharts 或 ECharts（用于统计图表）

### 1.2 本地存储技术栈
- **IndexedDB封装库：** Dexie.js 或 idb
- **数据同步：** 自研同步机制，支持本地优先（Local-first）架构
- **数据加密：** Web Crypto API（用于敏感数据加密）

### 1.3 后端技术栈（可选，用于云端备份）
- **运行时：** Node.js 18+ 或 Python 3.10+
- **框架：**
  - Node.js：Express 或 Fastify
  - Python：FastAPI 或 Flask
- **数据库：**
  - 关系型：PostgreSQL 或 MySQL
  - 或 NoSQL：MongoDB
- **ORM/ODM：**
  - Node.js：Prisma 或 TypeORM
  - Python：SQLAlchemy 或 Tortoise ORM
- **认证：** JWT（JSON Web Token）
- **API文档：** Swagger/OpenAPI

### 1.4 AI与语音服务
- **语音识别：**
  - Web Speech API（浏览器原生，免费但功能有限）
  - 或第三方服务：百度语音、讯飞语音、Google Speech-to-Text API
- **AI分析：**
  - 大语言模型API：OpenAI GPT-4、Claude、或国内大模型（文心一言、通义千问等）
  - NLP处理：可结合 spaCy（Python）或自然语言处理库进行预处理

### 1.5 开发工具
- **代码规范：** ESLint + Prettier
- **类型检查：** TypeScript
- **测试框架：** Vitest（单元测试）+ React Testing Library（组件测试）
- **构建优化：** Vite 内置优化
- **包管理：** pnpm 或 npm

---

## 2. 系统架构设计

### 2.1 整体架构
采用**前后端分离**架构，支持**本地优先（Local-first）**模式：

```
┌─────────────────────────────────────────┐
│           前端应用 (React)               │
│  ┌──────────┐  ┌──────────┐           │
│  │   UI层   │  │ 业务逻辑层 │           │
│  └──────────┘  └──────────┘           │
│         │              │                │
│         └──────┬───────┘                │
│                │                        │
│         ┌──────▼───────┐                │
│         │  数据访问层   │                │
│         └──────┬───────┘                │
└─────────────────┼───────────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
┌───────▼──────┐   ┌────────▼────────┐
│  IndexedDB   │   │  后端API服务    │
│  (本地存储)   │   │  (可选，云端)   │
└──────────────┘   └─────────────────┘
                           │
                  ┌────────▼────────┐
                  │   数据库/存储    │
                  └─────────────────┘
```

### 2.2 数据流设计
- **写入流程：** 用户操作 → 业务逻辑层 → 数据访问层 → IndexedDB（立即）→ 后端API（异步，如果开启云端备份）
- **读取流程：** IndexedDB（优先）→ 如果数据过期或不存在，从后端API同步
- **同步策略：** 
  - 本地优先：所有操作先写入本地，后台异步同步到云端
  - 冲突解决：采用"最后写入获胜"或"用户选择"策略

---

## 3. 数据存储方案

### 3.1 本地存储（IndexedDB）

#### 3.1.1 数据库设计
使用 Dexie.js 封装 IndexedDB，设计以下数据表：

**Tasks（任务表）**
- id: string (主键)
- title: string
- description: string
- type: 'single' | 'recurring' | 'long_term' (任务类型：单次、重复、长期)
- status: 'pending' | 'in_progress' | 'completed' | 'archived' | 'skipped'
- priority: 'high' | 'medium' | 'low' | null
- tags: string[]
- category: string | null
- startDate: Date | null
- startTime: string | null
- deadline: Date | null
- endDate: Date | null (长期任务的结束日期)
- recurrenceRule: object (RRULE格式或自定义格式)
- recurrenceEndDate: Date | null
- recurrenceCount: number | null
- parentTaskId: string | null (用于子任务，关联到长期任务)
- progress: number (0-100，用于长期任务)
- completedAt: Date | null
- createdAt: Date
- updatedAt: Date
- syncStatus: 'synced' | 'pending' | 'conflict' (用于云端同步)

**Journals（日记表）**
- id: string (主键)
- date: Date
- title: string | null
- content: string (Markdown格式)
- mood: string | null
- tags: string[]
- relatedTaskIds: string[] (关联的已办任务ID)
- createdAt: Date
- updatedAt: Date
- encrypted: boolean (是否加密)
- syncStatus: 'synced' | 'pending' | 'conflict'

**Tags（标签表）**
- id: string (主键)
- name: string
- color: string
- category: string | null
- createdAt: Date

**Settings（设置表）**
- key: string (主键)
- value: any (JSON格式)
- updatedAt: Date

**SyncLog（同步日志表）**
- id: string (主键)
- entityType: 'task' | 'journal'
- entityId: string
- operation: 'create' | 'update' | 'delete'
- timestamp: Date
- synced: boolean

#### 3.1.2 索引设计
为常用查询字段建立索引：
- Tasks: status, type, startDate, deadline, endDate, parentTaskId, tags
- Journals: date, tags

### 3.2 云端存储（可选）

#### 3.2.1 数据库选型
- **推荐：** PostgreSQL（关系型，支持复杂查询和事务）
- **备选：** MongoDB（NoSQL，灵活但查询能力相对较弱）

#### 3.2.2 数据同步机制
- **增量同步：** 只同步变更的数据
- **批量同步：** 合并多个操作，减少网络请求
- **冲突处理：** 
  - 时间戳比较
  - 版本号机制
  - 用户手动选择
- **离线队列：** 离线时的操作存入队列，联网后批量同步

#### 3.2.3 数据加密
- **传输加密：** HTTPS
- **存储加密：** 敏感字段（如日记内容）使用AES加密
- **密钥管理：** 用户密码派生密钥，或使用设备密钥

---

## 4. 前端架构设计

### 4.1 项目结构
```
src/
├── components/          # 通用组件
│   ├── common/          # 基础组件（Button, Input等）
│   ├── calendar/        # 日历相关组件
│   ├── task/            # 任务相关组件
│   ├── journal/         # 日记相关组件
│   └── voice/           # 语音相关组件
├── pages/               # 页面组件
│   ├── TaskList/        # 任务列表页
│   ├── Calendar/        # 日历页
│   ├── Journal/         # 日记页
│   └── Settings/        # 设置页
├── stores/              # 状态管理（Zustand/Redux）
│   ├── taskStore.ts
│   ├── journalStore.ts
│   └── settingsStore.ts
├── services/            # 业务服务层
│   ├── taskService.ts
│   ├── journalService.ts
│   ├── syncService.ts   # 同步服务
│   └── aiService.ts     # AI服务
├── utils/               # 工具函数
│   ├── dateUtils.ts
│   ├── recurrenceUtils.ts  # 重复任务工具
│   ├── encryption.ts    # 加密工具
│   └── validators.ts
├── hooks/               # 自定义Hooks
│   ├── useTasks.ts
│   ├── useCalendar.ts
│   └── useVoice.ts
├── types/               # TypeScript类型定义
│   ├── task.ts
│   └── journal.ts
├── db/                  # 数据库访问层
│   ├── database.ts      # Dexie数据库实例
│   ├── taskRepository.ts
│   └── journalRepository.ts
├── api/                 # API调用（云端）
│   ├── client.ts        # API客户端
│   ├── taskApi.ts
│   └── syncApi.ts
└── App.tsx
```

### 4.2 状态管理方案

#### 4.2.1 状态管理库选择
推荐使用 **Zustand**，原因：
- 轻量级，API简洁
- 无需Provider包裹
- 支持中间件（持久化、DevTools等）
- TypeScript支持良好

#### 4.2.2 Store设计
- **TaskStore：** 管理任务相关状态（列表、筛选、排序）
- **JournalStore：** 管理日记相关状态
- **SettingsStore：** 管理应用设置（主题、同步开关等）
- **UIStore：** 管理UI状态（侧边栏、弹窗等）

### 4.3 组件设计原则
- **原子化设计：** 遵循原子设计原则（原子、分子、组织、模板、页面）
- **组件复用：** 提取通用组件，避免重复代码
- **性能优化：** 使用 React.memo、useMemo、useCallback 优化渲染
- **响应式设计：** 使用媒体查询和响应式布局，适配PC和移动端

### 4.4 路由设计
- `/` - 首页（任务列表或日历）
- `/tasks` - 任务列表页
- `/calendar` - 日历页
- `/journal` - 日记页
- `/journal/:date` - 指定日期的日记
- `/settings` - 设置页

---

## 5. 核心功能技术实现

### 5.1 重复任务处理

#### 5.1.1 重复规则设计
采用类似 RRULE 的规则格式：
```typescript
interface RecurrenceRule {
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
  interval: number; // 间隔（如：每3天）
  byWeekday?: number[]; // 星期几（0=周日，1=周一...）
  byMonthDay?: number[]; // 每月几号
  byWeek?: number[]; // 第几周
  endType: 'never' | 'count' | 'date'; // 结束类型
  endCount?: number; // 重复次数
  endDate?: Date; // 结束日期
  excludeDates?: Date[]; // 排除的日期
}
```

#### 5.1.2 任务实例生成
- **策略1（推荐）：** 按需生成
  - 不预先生成所有实例
  - 在日历视图或列表视图中，根据日期范围动态计算并生成任务实例
  - 优点：节省存储空间，灵活处理规则变更
  - 缺点：需要实时计算，可能影响性能

- **策略2：** 预生成实例
  - 创建重复任务时，预生成未来N个月（如6个月）的实例
  - 后台任务定期生成新的实例
  - 优点：查询快速
  - 缺点：存储占用大，规则变更复杂

**推荐采用策略1，结合缓存优化性能。**

### 5.2 日历视图实现

#### 5.2.1 视图组件
- **月视图：** 网格布局，每个日期单元格显示任务标记
- **周视图：** 时间轴布局，左侧时间列，右侧任务条
- **日视图：** 详细时间轴，按小时划分

#### 5.2.2 性能优化
- **虚拟滚动：** 周视图和日视图使用虚拟滚动，只渲染可见区域
- **任务聚合：** 月视图中，同一日期任务过多时，显示"更多"标记
- **按需加载：** 只加载当前视图范围内的任务数据
- **缓存策略：** 缓存已计算的任务实例，避免重复计算

#### 5.2.3 拖拽功能
使用 `@dnd-kit/core` 实现：
- 任务拖拽到其他日期
- 在日历上拖拽创建新任务
- 调整任务时间范围（周视图/日视图）

### 5.3 语音录入实现

#### 5.3.1 浏览器原生方案
使用 Web Speech API：
- **优点：** 免费，无需后端，隐私性好
- **缺点：** 浏览器兼容性有限，识别准确率一般

#### 5.3.2 第三方服务方案
集成第三方语音识别服务：
- **百度语音识别API**
- **讯飞语音识别API**
- **Google Speech-to-Text API**

**实现策略：** 优先使用浏览器原生API，如果不支持或准确率不够，降级到第三方服务。

#### 5.3.3 实时语音转文字
- 使用 Web Speech API 的 `SpeechRecognition` 接口
- 实时显示识别结果
- 支持中英文切换
- 提供编辑和修正功能

### 5.4 AI分析实现

#### 5.4.1 NLP处理流程
```
用户输入（语音/文字）
    ↓
语音转文字（如需要）
    ↓
文本预处理（清理、分词）
    ↓
AI模型分析（提取时间、任务类型等）
    ↓
结构化数据生成
    ↓
用户确认/修改
    ↓
创建任务
```

#### 5.4.2 时间提取
- **相对时间：** "明天"、"下周"、"下个月" → 转换为具体日期
- **模糊时间：** "早上"、"下午"、"晚上" → 转换为具体时间点（可配置）
- **重复规则：** "每天"、"每周一" → 转换为重复规则对象
- **长期任务识别：** "3个月"、"半年"、"一年" → 识别为长期任务类型

#### 5.4.3 AI服务集成
- **方案1：** 直接调用大语言模型API（GPT-4、Claude等）
  - 使用 Prompt Engineering 提取结构化信息
  - 返回 JSON 格式的任务数据
  
- **方案2：** 自建NLP服务（Python）
  - 使用 spaCy 或 jieba 进行中文分词
  - 使用规则引擎 + 机器学习模型提取信息
  - 提供 RESTful API 供前端调用

**推荐方案1（MVP阶段），后续可优化为方案2以提高准确率和降低成本。**

### 5.5 数据同步实现

#### 5.5.1 同步策略
- **本地优先：** 所有操作先写入本地IndexedDB
- **后台同步：** 使用 Service Worker 或 Web Worker 在后台同步
- **增量同步：** 只同步变更的数据，使用时间戳或版本号
- **冲突解决：** 检测冲突，提示用户选择或采用"最后写入获胜"

#### 5.5.2 同步流程
1. 用户操作 → 写入IndexedDB → 标记为待同步
2. 后台检测到网络连接 → 读取待同步数据
3. 调用后端API同步数据
4. 同步成功后更新本地记录的同步状态
5. 如果同步失败，保留在待同步队列，下次重试

#### 5.5.3 离线支持
- 使用 Service Worker 实现离线缓存
- 核心功能（任务CRUD）完全支持离线
- 语音识别和AI分析需要网络，离线时提示用户

---

## 6. 后端架构设计（可选）

### 6.1 API设计

#### 6.1.1 RESTful API规范
- `GET /api/tasks` - 获取任务列表
- `POST /api/tasks` - 创建任务
- `PUT /api/tasks/:id` - 更新任务
- `DELETE /api/tasks/:id` - 删除任务
- `POST /api/sync` - 批量同步数据
- `GET /api/sync/status` - 获取同步状态

#### 6.1.2 认证授权
- 使用 JWT Token 进行身份认证
- Token存储在 localStorage 或 httpOnly cookie
- 支持Token刷新机制

### 6.2 数据库设计（PostgreSQL示例）

#### 6.2.1 表结构
- **users** - 用户表
- **tasks** - 任务表（与本地结构对应）
- **journals** - 日记表
- **tags** - 标签表
- **sync_logs** - 同步日志表

#### 6.2.2 数据关系
- users 1:N tasks
- users 1:N journals
- tasks 1:N tasks (长期任务与子任务的关系)
- tasks M:N tags (多对多关系)

---

## 7. 性能优化方案

### 7.1 前端性能优化
- **代码分割：** 使用 React.lazy 和 Suspense 实现路由级别的代码分割
- **资源优化：** 图片懒加载、字体子集化
- **缓存策略：** 
  - 静态资源使用强缓存
  - API数据使用适当的缓存策略
- **虚拟滚动：** 长列表使用虚拟滚动
- **防抖节流：** 搜索、筛选等操作使用防抖

### 7.2 数据库性能优化
- **索引优化：** 为常用查询字段建立索引
- **查询优化：** 避免全表扫描，使用分页
- **数据分页：** 列表查询使用分页，避免一次性加载大量数据

### 7.3 渲染性能优化
- **React优化：** 
  - 使用 React.memo 避免不必要的重渲染
  - 使用 useMemo 和 useCallback 缓存计算结果
  - 合理使用 Context，避免过度渲染
- **日历渲染：** 只渲染可见区域的任务，使用虚拟化技术

---

## 8. 安全性方案

### 8.1 数据加密
- **传输加密：** 所有API请求使用HTTPS
- **存储加密：** 敏感数据（日记内容）使用AES-256加密
- **密钥管理：** 使用用户密码派生加密密钥，或使用设备密钥

### 8.2 隐私保护
- **本地优先：** 默认数据存储在本地，不上传云端
- **用户控制：** 云端备份功能由用户主动开启
- **数据最小化：** 只同步必要的数据字段
- **匿名化：** 如需要分析数据，先进行匿名化处理

### 8.3 输入验证
- **前端验证：** 用户输入进行格式验证
- **后端验证：** API接口进行数据校验和SQL注入防护
- **XSS防护：** 对用户输入进行转义，使用CSP策略

---

## 9. 响应式设计

### 9.1 断点设计
- **移动端：** < 768px
- **平板：** 768px - 1024px
- **PC端：** > 1024px

### 9.2 适配策略
- **移动端优先：** 采用移动端优先的设计策略
- **触摸优化：** 移动端按钮和交互区域足够大（至少44x44px）
- **布局适配：** 
  - 移动端：单列布局，底部导航
  - PC端：多列布局，侧边栏导航
- **字体缩放：** 使用相对单位（rem、em），支持系统字体缩放

---

## 10. 测试策略

### 10.1 单元测试
- **工具：** Vitest
- **覆盖范围：** 工具函数、业务逻辑、Hooks
- **目标覆盖率：** 80%+

### 10.2 组件测试
- **工具：** React Testing Library
- **测试内容：** 组件渲染、用户交互、状态变化

### 10.3 集成测试
- **工具：** Playwright 或 Cypress
- **测试内容：** 关键用户流程（创建任务、完成任务、写日记等）

### 10.4 E2E测试
- 测试完整的用户场景
- 覆盖主要功能路径

---

## 11. 部署方案

### 11.1 前端部署
- **静态托管：** 
  - Vercel（推荐，支持自动部署）
  - Netlify
  - GitHub Pages
  - 或自建Nginx服务器
- **CDN加速：** 使用CDN加速静态资源
- **PWA支持：** 配置Service Worker，支持离线访问和安装

### 11.2 后端部署（如需要）
- **云服务：** 
  - Node.js：Vercel、Railway、Heroku
  - Python：Railway、Render、Fly.io
- **容器化：** 使用Docker容器化部署
- **数据库：** 使用云数据库服务（如Supabase、PlanetScale）

### 11.3 CI/CD
- **GitHub Actions：** 自动化测试、构建、部署
- **工作流：** 
  - 代码提交 → 运行测试 → 构建 → 部署到测试环境
  - 合并到主分支 → 部署到生产环境

---

## 12. 后续扩展方案

### 12.1 原生移动端
- **技术选型：** 
  - React Native（代码复用率高）
  - 或 Flutter（性能更好，但需要重写）
- **数据同步：** 与Web端共享后端API，数据格式统一

### 12.2 小程序
- **技术选型：** 
  - 微信小程序：原生开发或使用Taro（多端统一）
  - 其他平台：使用Taro实现多端统一
- **功能适配：** 根据小程序平台限制，调整部分功能（如语音识别）

### 12.3 桌面应用
- **技术选型：** Electron 或 Tauri
- **优势：** 可以访问更多系统API，支持离线使用

### 12.4 浏览器扩展
- **功能：** 快速添加任务、查看今日任务
- **技术：** Chrome Extension API

---

## 13. 开发计划建议

### 13.1 MVP阶段（P0功能）
1. 搭建项目基础架构（React + Vite + TypeScript）
2. 实现IndexedDB数据存储
3. 实现基础任务CRUD
4. 实现基础日历视图（月视图）
5. 实现日记创建和查看
6. 实现基础语音录入（Web Speech API）

### 13.2 V1版本（P0 + P1功能）
1. 实现重复任务（基础规则）
2. 实现长期任务功能
3. 实现日历拖拽和任务创建
4. 实现AI分析（基础NLP）
5. 实现已办任务与日记关联
6. 实现响应式设计（移动端适配）

### 13.3 V2版本（P2功能）
1. 高级重复规则
2. 日历周视图和日视图
3. AI辅助建议
4. 日记统计和可视化
5. 任务筛选和排序
6. 云端备份功能（可选）

### 13.4 后续版本（P3功能）
1. 长期任务甘特图
2. 高级AI分析
3. 数据导出和报表
4. 多设备同步优化
5. 原生移动端应用
6. 小程序版本

---

## 14. 技术风险与应对

### 14.1 技术风险
1. **IndexedDB兼容性：** 部分旧浏览器不支持
   - **应对：** 提供降级方案（LocalStorage + 数据压缩），或提示用户升级浏览器

2. **语音识别准确率：** Web Speech API准确率有限
   - **应对：** 提供第三方服务降级方案，允许用户编辑识别结果

3. **AI分析准确率：** NLP提取信息可能不准确
   - **应对：** 提供用户确认和编辑机制，持续优化Prompt

4. **性能问题：** 大量重复任务可能导致性能问题
   - **应对：** 采用按需生成策略，使用虚拟滚动，优化算法

5. **数据同步冲突：** 多设备同步可能出现冲突
   - **应对：** 实现冲突检测和解决机制，提供用户选择

### 14.2 兼容性考虑
- **浏览器支持：** 
  - Chrome 90+
  - Firefox 88+
  - Safari 14+
  - Edge 90+
- **移动端浏览器：** iOS Safari、Chrome Mobile
- **降级方案：** 检测浏览器能力，不支持的功能提供替代方案或提示

---

## 15. 总结

本技术方案采用**React + Vite + TypeScript**作为前端技术栈，**IndexedDB**作为主要数据存储，支持**本地优先**架构。通过**可选的后端服务**实现云端备份功能，满足用户的数据安全需求。

方案设计充分考虑了：
- **性能优化：** 虚拟滚动、代码分割、缓存策略
- **用户体验：** 响应式设计、离线支持、流畅交互
- **可扩展性：** 模块化设计、清晰的架构、易于扩展
- **安全性：** 数据加密、隐私保护、输入验证

该方案可以支撑PRD中定义的所有功能需求，并为后续的原生移动端、小程序等扩展提供了技术基础。

